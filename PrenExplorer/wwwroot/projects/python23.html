<section class="project-container">
    <div class="project-container__logo">
        <img src="" alt="Logo" srcset="">
    </div>
    
    <p class="project-name">Урок 23. Введение в объектно-ориентированное программирование. Класс vs Объект.docx</p>
    <div class="description-block">
	    <article class="description-block__text">
              <p><b>ВВЕДЕНИЕ В ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ</b></p>
              <p>В мире нас окружают объекты (иногда их называют сущностями). Например, телевизоры. У них есть такие атрибуты, как название, экран, методы “включить”, “отключить”, “переключить канал”, “показать контент, передаваемый через HDMI” и т.п. Также есть такие сущности, как транспорт. У транспорта может быть “полезный груз” (т.е. данные), также могут быть методы “транспортировать”,  “двигаться”, “остановиться” и т.п.</p>
              <p>Понятие объектов из повседневной жизни повлияли на создание подхода к организации кода в программах, при котором программист создает объект через специальную конструкцию, закладывает хранение данных, и наделяет их какими-нибудь свойствами и поведением через методы (вспомните, например, метод .replace(), который имеется у строковых). Т.е. как в реальной жизни объекты имеют какие-то свойства, могут выполнять какие-либо действия, так и в коде наши объекты могут иметь свойства, вести себя так или иначе.</p>
              <p>Классы помогают нам логически группировать данные и функции. С помощью них, мы определяем то, какие данные должны храниться в них, и какие методы должны быть в них доступны. Мы не наваливаем все что попало под эту конструкцию, а напротив, группируем под ней данные и связанные с ними поведение.</p>
              <p>Также объектно-ориентированное программирование с помощью классов помогает нам делить объекты на разные группы, определять общие для представителей этого класса поведение и т.п.</p>
              <p><b>КЛАСС VS ОБЪЕКТ</b></p>
              <p>Классы в Python создаются с помощью ключевого слова class. Затем следует имя класса. Затем могут идти скобки, но их может и не быть</p>
              <p>Создадим класс у которого есть функция go() (мы помним, что в классах/объектах функции называются методами):</p>
              <p></p>
              <p>class Car:</p>
              <p>&emsp;    def go(self):</p>
              <p>&emsp;&emsp;        print('Whuuuuummmm!!!')</p>
              <p></p>
              <p>А так мы создаем объект:</p>
              <p>new_car = Car()</p>
              <p>Так мы пользуемся методом объекта:</p>
              <p>new_car.go()</p>
              <p>В этом примере мы создали объект new_car -- экземпляр (instance) класса Car. И вызвали метод у объекта.</p>
              <p><b>Когда применять объектно-ориентированное программирование?</b></p>
              <p><b>Объекты</b> -- это то, что имеет и данные и поведение. В вышеуказанном примере я специально создал простой пример только с поведением, но без данных.</p>
              <p>Если у нас есть только данные, то их можно сохранить в какой-нибудь структуре, например списке, и обходиться его методами. Ну а если же нам требуется только какое-либо поведение, то можно обойтись встроенными или написанными нами функциями.</p>
              <p>Кроме этого, в больших и сложных системах появляется необходимость группировки данных и функций в отдельные группы не только для обеспечения удобочитаемости, но и для удобства тестирования и переиспользования кода в различных участках проекта.</p>
              <p>Для демонстрации сгруппированности поведения и данных в классах/объектах, продолжим пример с машиной. Сначала напишем код нашего “виртуального автомобиля” в том виде, в каком мы привыкли писать -- без классов.</p>
              <p>old_car = {</p>
              <p>&emsp;    'make': 'Subaru',</p>
              <p>&emsp;    'model': 'Legacy',</p>
              <p>&emsp;    'year': 2003,</p>
              <p>&emsp;    'odometer': 0</p>
              <p>}</p>
              <p>Ок. Мы здесь описали машину. Т.е. у нас есть данные. Теперь добавим поведение: нужна функция, которая должна имитировать езду машины, и будет регистрировать в одометре количество километров, которые наша машина проехала. Для этого нам придется написать отдельную функцию и держать “одометр” внутри нашего словаря:</p>
              <p>old_car = {</p>
              <p>&emsp;    'owner': 'Murat',</p>
              <p>&emsp;    'make': 'Subaru',</p>
              <p>&emsp;    'model': 'Legacy',</p>
              <p>&emsp;    'year': 2003,</p>
              <p>&emsp;    'odometer': 0</p>
              <p>}</p>
              <p></p>
              <p>def car_go(car, kms):</p>
              <p>&emsp;    odometer = car.get('odometer', 0)</p>
              <p>&emsp;    car['odometer'] = odometer + kms</p>
              <p>&emsp;    return car</p>
              <p></p>
              <p>old_car = car_go(old_car, 120)</p>
              <p>print(old_car)</p>
              <p>old_car = car_go(old_car, 15)</p>
              <p>print(old_car)</p>
              <p>Стоп. У нас есть данные, также есть поведение. Кроме этого, вполне может возникнуть необходимость в добавлении нового поведения. Сейчас у нас данные и поведение “размазаны” в двух местах: в словаре и функции. Это значит, что мы можем применить здесь объектно-ориентированный подход.</p>
              <p>Поехали. Сначала создадим класс:</p>
              <p>class Car:</p>
              <p>&emsp;    def __init__(self, automobile_owner, automobile_make, automobile_model, production_year):</p>
              <p>&emsp;&emsp;        self.owner = automobile_owner</p>
              <p>&emsp;&emsp;        self.make = automobile_make,</p>
              <p>&emsp;&emsp;        self.model = automobile_model,</p>
              <p>&emsp;&emsp;        self.year = production_year</p>
              <p>&emsp;&emsp;        self.odometer = 0</p>
              <p></p>
              <p>&emsp;    def go(self, km):</p>
              <p>&emsp;&emsp;        self.odometer = self.odometer + km</p>
              <p>&emsp;&emsp;        print('Whooooommm!!!')</p>
              <p></p>
              <p>Затем создаем объект (экземпляр класса Car):</p>
              <p>new_car = Car('Murat', 'Subaru', 'Legacy', 2003)</p>
              <p>Наша машина “масловая”. Проверим показатель одометра:</p>
              <p>print(new_car.odometer)</p>
              <p>Проедем 121 км на ней:</p>
              <p>new_car.go(121)</p>
              <p>Проверим показатель одометра:</p>
              <p>print(new_car.odometer)</p>
              <p>Давайте пока не будем обращать внимание на то, что происходит внутри класса. Сфокусируемся на том, что сейчас данные о машине и имеющееся поведение доступно в одном месте -- в объекте new_car. В случае с old_car, данные у нас хранились в одном месте, а поведение (т.е. функция) -- в другом. Если бы нам пришлось добавить еще несколько поведений, то читабельность/сгруппированность в случае с классом не пострадала бы, а без класса получилось бы хуже.</p>
              <p><b>Как устроен класс?</b></p>
              <p>Пока не будем детализировать. Остановимся на примере с машиной, который был приведен выше.</p>
              <p><b>Метод __init__()</b></p>
              <p>В других языках называется конструктор.</p>
              <p>Ответственен за инициализацию (создание, проще говоря) экземпляра. Внутри этого метода происходит “старт” всего: переданные аргументы сохраняются внутри объекта, задаются начальные данные. В __init__() если кроме self указаны какие-то параметры, то это значит, что для создания экземпляра этого класса (т.е. объекта), нам нужно передать аргументы. В случае с вышеуказанным примером, объект мы создавали передав имя владельца, название марки, модели и года выпуска машины.</p>
              <p><b>self</b></p>
              <p>Методы класса отличаются от обычных функций тем, что у них всегда первым параметром идет self. В примере выше вы видели их:</p>
              <p>def __init__(self, …):</p>
              <p>def go(self):</p>
              <p>В чем смысл этого странного слова? Через это слово функция связывает себя с объектом, то есть, таким образом, происходит единение метода с объектом. </p>
              <p>При обращении к методам, нам не нужно передавать аргументы для self -- Python сам это делает. За кулисами это происходит так (для примера возьмем метод go()): </p>
              <p>мы создали объект new_car = Car(....) и вызвали метод new_car.go(). А Python чтобы было понятно для себя, конвертирует это в следующий вид: Car.go(new_car). Как мы помним, в классе Car в методе go() первым параметром был self. Python же “подменяет” этот self созданным объектом.</p>
              <p><b>Задания:</b></p>
              <p>1. Добавьте в класс Car переменную объекта “is_going”, в котором по умолчанию будет False. Когда метод go() вызван, значение должно поменяться на True.</p>
              <p>2. Добавьте метод stop(), при вызове которого нужно записать False в переменную объекта “is_going”.</p>
              <p>3. Напишите класс Airplane. Создайте несколько переменных (полей) объекта и несколько методов, имитирующих поведение самолетов.</p>
              <p>4. Есть ферма, которую нужно имитировать. У фермы есть название и бюджет. Ферма может сажать морковь, капусту, картошку. Также может собирать морковь, капусту, картошку. Когда сажают морковь, на каждый посаженный килограмм расходуется 1 сом. В случае с капустой 5 сом, а на килограмм картошки расходуется 2 сом. Реализуйте класс, создайте ферму с бюджетом, посадите овощи (по 20 кг. каждого вида) и выведите состояние бюджета после посадки.</p>
          </article>
        <div class="description-block__image">
            <img src="" alt="" srcset="">
        </div>
    </div>
</section>