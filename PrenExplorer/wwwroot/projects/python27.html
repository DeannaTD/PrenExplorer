<section class="project-container">
    <div class="project-container__logo">
        <img src="" alt="Logo" srcset="">
    </div>
    
    <p class="project-name">Урок 27. Наследование</p>
    <div class="description-block">
	    <article class="description-block__text">
            <p>Перед тем как приступим к изучению наследования, вспомним что такое классы и для чего они необходимы.</p>
            <p>Классы -- это конструкции, которые позволяют нам создавать сложные структуры данных, содержащих данные и имеющих поведение.</p>
            <p>Данные хранятся в <b>переменных класса</b> и <b>переменных экземпляра (объекта) класса</b>. Иногда эти переменные называются <b>полями</b>.</p>
            <p>Поведение реализовывается через методы -- функции, записанных внутри классов.</p>
            <p>Класс -- “заливочная форма” (шаблон), экземпляр (объект) класса -- “шоколад”, изготовленный с помощью данной формы. Еще одна аналогия: допустим есть форма налоговой декларации, которая одинакова для всех. Это и есть класс. А заполненная форма налоговой декларации -- это экземпляр. То есть, форма одна, заполненных экземпляров форм может быть великое множество.</p>
            <p><b>Для чего нужны классы? В чем их преимущество.</b></p>
            <p><b> 1. Классы улучшают читабельность кода</b>. Когда мы используем их, мы используем стандартизированный способ описания предметов/понятий, которые известны практически всем программистам. Классы лучше, чем сложные, вложенные словари или списки внутри списков (которые мы иногда используем для описания сложных данных), так как их атрибуты можно именовать, из чего нам легче понять для чего они нужны.</p>
            <p><b>2. Хранение состояния</b>. Классы помогают определить и управлять состоянием объектов. Например, если мы пишем программу, которая ведет информацию по студентам, вся информация о них будет доступна в одном месте (ФИО, курс, оценки, преподаватели и т.п.), и данные будут сохранены до тех пор, пока объект будет жить.</p>
            <p><b> 3. Инкапсуляция</b>. То, о чём мы ранее говорили -- когда поведение (процедура) и данные размещены в одном месте (в классе). Методы написаны рядом с данными, над которыми они работают, либо которых они производят. В таких языках как PHP или Java, это еще может означать и ограничение доступа только к определенным переменным или методам (через ключевые слова private), что обеспечивает сокрытие деталей имплементации. То есть, мы делаем доступными только те методы и переменные, которые не будут менять поведение или выдаваемый тип данных, тогда как приватные методы и данные могут менять свое поведение (обеспечивается гибкость)</p>
            <p><b> 4. Наследование</b>. Определение данных и процедур в одном месте (в одном классе) и небольшая кастомизация в другом. То есть, наследование подразумевает наличие родительского класса и дочернего (или нескольких дочерних) классов. Дочерний класс может иметь все атрибуты родительского класса, и переопределить (изменить поведение) некоторых из них. Также могут быть добавлены какие-либо другие атрибуты в дочерний класс. </p>
            <p>Например, мы можем унаследоваться от класса str и добавить метод reverse() для отображения строкового значения в обратном порядке. Также мы можем унаследоваться от родительского класса и переопределить поведение того или иного метода, но оставить все остальные методы и переменные неизменными.</p>
            <p><b> 5. Переиспользуемость</b>. Все перечисленные, а также другие факторы могут привести к переиспользуемости кода. Объектно-ориентированный код позволяет написать тестируемый код один раз и переиспользовать его во многих местах. Если вам необходимо внести изменения в одном участке, вы можете унаследоваться от класса и переопределить только тот участок. Если вам необходимо изменить поведение класса, вы можете сделать это без изменения сигнатуры публичных методов.</p>
            <p></p>
            <p><b>Наследование</b></p>
            <p>Иногда, одного класса недостаточно, и мы начинаем создавать другие классы. Если взять в качестве примера животных, то поводом для размножения классов может послужить наше желание разделить животных на млекопитающих и не млекопитающих,  и т.п. Ок, мы можем для каждого вида создать свои классы, но многие атрибуты будут повторяться: наличие/отсутствие рогов, наличие/отсутствие крыльев и т.п. DRY!</p>
            <p>Для того, чтобы не повторяться, мы можем написать один класс Animal, и унаследоваться от него для описания того или иного вида животных.</p>
            <p>Например:</p>
            <p>class Animal:</p>
            <p>&emsp;    def __init__(self, gender, age, is_mammal):</p>
            <p>&emsp;&emsp;        self.gender = gender</p>
            <p>&emsp;&emsp;        self.age = age</p>
            <p>&emsp;&emsp;        self.is_mammal = is_mammal</p>
            <p></p>
            <p>&emsp;    # Этот метод имплементирован по умолчанию для</p>
            <p>&emsp;    # всех субклассов Animal</p>
            <p>&emsp;    def give_meat(self):</p>
            <p>&emsp;&emsp;        if self.is_mammal:</p>
            <p>&emsp;&emsp;&emsp;            return 'Here goes my meat'</p>
            <p>&emsp;&emsp;        return 'Here goes my meat, but not plenty'</p>
            <p></p>
            <p>&emsp;    # Этот метод не имплементирован. Субклассы обязательно</p>
            <p>&emsp;    # должны реализовать его</p>
            <p>&emsp;    def make_sound(self):</p>
            <p>&emsp;&emsp;        raise NotImplementedError</p>
            <p></p>
            <p>&emsp;    # Этот метод может вызвыть метод make_sound() дважды</p>
            <p>&emsp;    # но для этого, последний должен быть реализован</p>
            <p>&emsp;    def make_sound_twice(self):</p>
            <p>&emsp;&emsp;        self.make_sound()</p>
            <p>&emsp;&emsp;        self.make_sound()</p>
            <p></p>
            <p>&emsp;    # Этот метод также не имплементирован. Субклассы</p>
            <p>&emsp;    # обязательно должны реализовать его</p>
            <p>&emsp;    def get_trained(self):</p>
            <p>&emsp;&emsp;        raise NotImplementedError</p>
            <p></p>
            <p>class Dog(Animal):</p>
            <p>&emsp;    def __init__(self, gender, age, name):</p>
            <p>&emsp;&emsp;        Animal.__init__(self, gender, age, is_mammal=True)</p>
            <p>&emsp;&emsp;        self.name = name</p>
            <p></p>
            <p>&emsp;    def make_sound(self):</p>
            <p>&emsp;&emsp;        print("GavGav")</p>
            <p></p>
            <p>&emsp;    def get_trained(self):</p>
            <p>&emsp;&emsp;        print("I am trained and I can speak now :)")</p>
            <p></p>
            <p>rex = Dog('male', 3, 'Rex')</p>
            <p>trained = rex.get_trained()</p>
            <p>meat = rex.give_meat()</p>
            <p>rex.make_sound()</p>
            <p>rex.get_trained()</p>
            <p>print(rex.is_mammal)</p>
            <p>print(meat)</p>
            <p></p>
            <p>В родительском классе могут быть реализованы методы по умолчанию, но в субклассах они могут быть переопределены. В случае с котом, мы решили, что нам нужно переопределить метод give_meat():</p>
            <p>class Cat(Animal):</p>
            <p>&emsp;    def __init__(self, gender, age, name):</p>
            <p>&emsp;&emsp;        Animal.__init__(self, gender, age, is_mammal=True)</p>
            <p>&emsp;&emsp;        self.name = name</p>
            <p></p>
            <p>&emsp;    # Мы решили переопределить стандартное поведение</p>
            <p>&emsp;    # данного метода</p>
            <p>&emsp;    def give_meat(self):</p>
            <p>&emsp;&emsp;        return "Sorry, I can't give you my meat"</p>
            <p></p>
            <p>&emsp;    def make_sound(self):</p>
            <p>&emsp;&emsp;        print('Meooow')</p>
            <p></p>
            <p>&emsp;    def get_trained(self):</p>
            <p>&emsp;&emsp;        print("Ыя?")</p>
            <p></p>
            <p>tom = Cat('male', 1, 'Tom')</p>
            <p>tom.make_sound_twice()</p>
            <p></p>
            <p>Обратите внимание на методы make_sound, get_trained. В них нет какого-либо поведения, кроме того, что они выкидывают ошибку. Такие методы мы реализовываем для того, чтобы заложить шаблон для всех субклассов. То есть, субкласс должен обязательно реализовать поведение данных методов у себя. Мы приходим к пониманию, что сам по себе класс Animal практически ничем не полезен. В других языках этот класс называется абстрактным классом. Абстрактный класс -- это когда у класса есть как имплементированные так и не имплементированные методы, у такого класса может быть состояние и переменные экземпляра.</p>
            <p></p>
            <p>Мы также можем наследоваться от встроенных классов, таких как int, str, dict и т.п.</p>
            <p>Пример с наследованием от класса str:</p>
            <p>class sstr(str):</p>
            <p>&emsp;    def reverse(self):</p>
            <p>&emsp;&emsp;        obj = self.__str__()</p>
            <p>&emsp;&emsp;        return obj[::-1]</p>
            <p></p>
            <p>new_st = sstr('testing')</p>
            <p>reversed_string = new_st.reverse()</p>
            <p>print(reversed_string)</p>
            <p></p>
            <p><b>Задания:</b></p>
            <p>1. Реализуйте родительский класс Publication, конструктор которого принимает name, date, pages, library, type</p>
            <p>2. Создайте субкласс Book. В конструктор родительского класса должен передавать type=’book’</p>
            <p>3. Создайте субкласс Magazine. В конструктор родительского класса должен передавать type=’magazine’</p>
            <p>4. Создайте субкласс Newspaper. В конструктор родительского класса должен передавать type=’newspaper’</p>
            <p>5. В классе Publication создайте метод get_code_in_library() который будет возвращать первые_2_буквы_библиотеки_тип_первые_2_буквы_названия_количество_страниц_дата_без_точек</p>
            <p>6. Придумайте свои варианты применения наследования. Возьмите в качестве примера транспорт, здание, персонажи какой-нибудь игры, фигур шахмат и т.п.</p>
            <p></p>
          </article>
        <div class="description-block__image">
            <img src="" alt="" srcset="">
        </div>
    </div>
</section>